<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>signal | iVoid</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">iVoid</a><span class="subtitle"></span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>signal</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2016-03-05</div></div></div><article><div class="container post"><p>信号被称为是Linux系统的软中断，是Linux进程间通信的一种方式。信号的本质是对硬件中断机制的一种模拟，下面列出了几个常用的信号处理函数。</p>
<h3 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h3><p>原型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">typedef void (*sighandler_t)(int);</span><br><span class="line"></span><br><span class="line">sighandler_t signal(int signum, sighandler_t handler);</span><br></pre></td></tr></table></figure></p>
<p>–!<more>–<br>signal函数的返回值是一个指向参数为int,返回void的函数。若成功，返回以前的信号处理配置，若出错，返回SIG_ERR。<br>其中，signum是信号名，可以用<code>kill -l</code>查看所有的信号名，handler是信号处理函数名字。第二个参数的值还可以是<code>SIG_IGN</code>和<code>SIG_DFL</code>，分别表示内核忽略次信号和接到此信号是系统默认动作。<br><strong>使用signal函数，就是捕捉要发出的信号，当这个信号发生时，就执行处理函数。</strong><br>下面看一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">void handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;signal triggered.\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    signal(SIGINT, handler);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;hello\n&quot;);</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></more></p>
<p>程序会一直以1秒间隔打印hello，当按下<code>ctrl+c</code>时，会打印一次<code>signal triggered</code>，即SIGINT信号被触发了。</p>
<h3 id="kill和raise函数"><a href="#kill和raise函数" class="headerlink" title="kill和raise函数"></a>kill和raise函数</h3><p>kill函数是向某个进程发起一个信号，原型为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">int kill(pid_t pid, int sig);</span><br></pre></td></tr></table></figure></p>
<p>pid是要发送的进程id，sig是要发送的信号名。<br>如<code>kill(getpid(), SIGINT)</code>就是向当前进程发送SIGINT信号。</p>
<p>raise函数允许进程向自身发送信号。原型为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int raise(int signo);</span><br></pre></td></tr></table></figure></p>
<p>调用<code>kill(getpid(), int sig)</code>等于调用<code>raise(int sig)</code>。</p>
<h3 id="alarm和pause函数"><a href="#alarm和pause函数" class="headerlink" title="alarm和pause函数"></a>alarm和pause函数</h3><p>alarm函数是设置一个定时器，在将来的某个时刻定时器会超时，当定时器超时，产生SIGALRM信号。 如果忽略或者不捕捉次信号，则默认动作是终止调用alarm函数的进程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned int alarm(unsigned int seconds);</span><br></pre></td></tr></table></figure></p>
<p>pause函数使调用进程挂起直至捕获到一个信号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int pause(void);</span><br></pre></td></tr></table></figure></p>
<h3 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h3><p>这个函数用来替代signal函数，也更推荐去使用这个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</span><br></pre></td></tr></table></figure></p>
<p>signum是信号名，act参数是一个sigaction类型的结构，这个结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct sigaction &#123;</span><br><span class="line">    void     (*sa_handler)(int);</span><br><span class="line">    void     (*sa_sigaction)(int, siginfo_t *, void *);</span><br><span class="line">    sigset_t   sa_mask;</span><br><span class="line">    int        sa_flags;</span><br><span class="line">    void     (*sa_restorer)(void);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>ss_handler</code>指向信号处理的函数，<code>sa_mask</code>说明了一个信号集，在调用该信号捕捉函数之前，这个信号集要加到进程的信号屏蔽字中。如果不需要屏蔽字，可以用函数<code>sigemptyset(&amp;sa_mask);</code>来将该成员清空。sa_flags一般赋值为0。<br>下面用sigaction改写上面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">void handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;signal triggered.\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct sigaction act;</span><br><span class="line">    act.sa_handler = handler;</span><br><span class="line">    sigemptyset(&amp;sa_mask);</span><br><span class="line">    act.sa_flags = 0;</span><br><span class="line"></span><br><span class="line">    sigaction(SIGINT, &amp;act, 0);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;hello\n&quot;);</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序执行效果和原来的一样。</p>
<h3 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h3><p>信号集是一组用来处理<code>sigset_t</code>类型的函数，sigaction和其他函数将通过信号集来设置接受到信号时的行为。<br>信号集包括一下几个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">int sigemptyset(sigset_t *set);</span><br><span class="line"></span><br><span class="line">int sigfillset(sigset_t *set);</span><br><span class="line"></span><br><span class="line">int sigaddset(sigset_t *set, int signum);</span><br><span class="line"></span><br><span class="line">int sigdelset(sigset_t *set, int signum);</span><br><span class="line"></span><br><span class="line">int sigismember(const sigset_t *set, int signum);</span><br></pre></td></tr></table></figure></p>
<p>sigemptyset将信号集初始化为空，sigfillset将信号集初始化为包含所有已定义的信号，sigaddset和sigdelset分别是将指定的signo从信号集种添加或删除。它们在成功时返回0，失败时返回-1并设置errno。<br>sigismember判断一个给定的信号是不是信号集的成员，是返回1，不是返回0。如果给定的信号无效，返回-1并设置error为EINVAL。</p>
</div><!-- comment system--><div class="container"><hr></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div><div class="footer">© 2016 <a href="/" rel="nofollow">iVoid</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});</script></body></html>